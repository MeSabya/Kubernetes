### VirtualService: 
A VirtualService in Istio represents a set of routing rules that determine how incoming requests are routed to different services within the mesh. 
It can represent multiple services or endpoints of an application and define how traffic should be directed to those services based on various criteria such as URI path, headers, or request methods.

### DestinationRule: 
On the other hand, a DestinationRule in Istio is specific to a single service or endpoint within the mesh. It defines subsets of instances for that service based 
on labels and allows you to apply traffic policies such as load balancing settings, TLS settings, and circuit breaking specifically to those subsets.

### In summary:
- VirtualService: Defines routing rules for traffic across multiple services or endpoints.
- DestinationRule: Defines subsets and policies for a single service or endpoint.

Together, VirtualServices and DestinationRules provide powerful capabilities for managing traffic routing and policy enforcement within Istio service meshes, 
enabling fine-grained control over how requests are handled and processed within your application architecture.

## Realtime usecases discussion 
***Suppose my application has three services ..shopping , booking and ticketing ..how can i apply a virtual service and destination rules for each service .. 
can we have a single virtual service and multiple destination rules here ?***


```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: gateway
spec:
  hosts:
  - "*"
  gateways:
  - ingress-gateway
  http:
  - match:
    - uri:
        prefix: "/shopping"
    route:
    - destination:
        host: shopping-service
        subset: v1
  - match:
    - uri:
        prefix: "/booking"
    route:
    - destination:
        host: booking-service
        subset: v1
  - match:
    - uri:
        prefix: "/ticketing"
    route:
    - destination:
        host: ticketing-service
        subset: v1
```

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: shopping-service
spec:
  host: shopping-service
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: booking-service
spec:
  host: booking-service
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: ticketing-service
spec:
  host: ticketing-service
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
```

***How can i have two deployment of my service one running with v1 and another with v2 ..can you give an example of this ?***
 Let's create an example where we have two deployments of a shopping service, one running version v1 and the other running version v2, using Kubernetes Deployment objects.

Here's how you can define two deployments for the shopping service with different versions:

#### Define Deployment for Version v1:
Create a Kubernetes Deployment object for version v1 of the shopping service. This deployment will contain pods running the v1 version of your shopping service.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: shopping-service-v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: shopping-service
      version: v1
  template:
    metadata:
      labels:
        app: shopping-service
        version: v1
    spec:
      containers:
      - name: shopping-service
        image: shopping-service:v1
        ports:
        - containerPort: 8080
```
#### Define Deployment for Version v2:
Similarly, create another Kubernetes Deployment object for version v2 of the shopping service.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: shopping-service-v2
spec:
  replicas: 3
  selector:
    matchLabels:
      app: shopping-service
      version: v2
  template:
    metadata:
      labels:
        app: shopping-service
        version: v2
    spec:
      containers:
      - name: shopping-service
        image: shopping-service:v2
        ports:
        - containerPort: 8080
```




