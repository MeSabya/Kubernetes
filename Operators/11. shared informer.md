## Informer Vs Shared Informer 
<details>
By default, Kubebuilder uses controller-runtime, and the Manager automatically creates a shared cache and shared informers. Multiple controllers under the same Manager reuse those informers, so we don’t manually create SharedInformerFactory like we would in raw client-go, so there is no single informer when using kubebuilder. 

Imagine:

- Controller A watches Pods
- Controller B watches Pods
- Controller C watches Pods

Without shared informer:

- 3 separate watch connection
- 3 separate caches
- 3x API load

With shared informer:

- 1 watch connection
- 1 cache
- multiple event handlers

### Internal flow
```
API Server
    ↓
Reflector (List + Watch)
    ↓
SharedInformer
    ↓
Local Cache (thread-safe)
    ↓
Event Handlers
    ↓
WorkQueue
```

Using controller-runtime (Modern Operators)

when we're building operators using:

```
ctrl.NewControllerManagedBy(mgr).
    For(&MyCR{}).
    Owns(&corev1.ConfigMap{}).
    Complete(r)
```

***The Manager in controller-runtime:***

- Creates a shared cache
- Creates shared informers
- Shares them across controllers
- Wires them to workqueues


</details>

When monitoring Kubernetes resources such as pods or deployments, the traditional approach 
often involves frequently polling data from the Kubernetes API server. This is typically achieved through 
repetitive API calls, set to occur at regular intervals.

This approach, however, may not be the most efficient. Picture a scenario where no updates 
have been made to the Kubernetes resources between these polling intervals. 
In essence, nothing has changed since the last data retrieval,
and the subsequent API call only retrieves redundant information.

This is where the Shared Informer Factory comes in. Using a Shared Informer Factory is 
a more performance-friendly alternative. 
Instead of constantly polling the API server, it provides event-driven notifications.

<img width="796" height="564" alt="image" src="https://github.com/user-attachments/assets/82b3e229-ead7-4680-b276-1d1bad78073d" />

## What’s actually happening under the hood

When you do something like:

```go
ctrl.NewControllerManagedBy(mgr).
    For(&corev1.Pod{}).
    Complete(r)
```

Controller-runtime internally does:

- Registers an informer for Pods.
- Adds an event handler that enqueues reconcile requests.
- Starts the informer when you call mgr.Start().
- On every Add/Update/Delete, enqueues a reconcile request → your Reconcile() method runs.




  
