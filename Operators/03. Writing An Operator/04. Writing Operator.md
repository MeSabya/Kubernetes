## Generating scaffolding of CRDs for operator 
When it comes to scaffolding CRDs (Custom Resource Definitions) and building Kubernetes operators, both Kubebuilder and Operator SDK are popular frameworks.

1. Create a new project: Run the following command to create a new project with a sample API and controller:

```shell
$ mkdir -p $GOPATH/src/github.com/example/
$ cd $GOPATH/src/github.com/example/
$ kubebuilder init --domain example.com --repo=github.com/example/my-operator
$ kubebuilder create api --group=mygroup --version=v1alpha1 --kind=MyKind
```

2. This will generate the basic scaffolding for your operator, including a sample API and controller.

Define your custom resource: Open the ***api/v1alpha1/mykind_types.go*** file and modify the MyKindSpec and MyKindStatus structs to define the desired fields and status of your custom resource.
Generate the CRD: Run the following command to generate the CRD for your custom resource:

```shell
$ make manifests
```
This will generate the ***config/crd/bases/mygroup.example.com_mykinds.yaml*** file, which contains the CRD for your custom resource.

3. Now write your controller logic: Open the controllers/mykind_controller.go file and write the logic for your controller. This will typically involve watching for changes to your custom resource, reconciling the desired state with the actual state, and updating the status of your resource as necessary.

4. Build and deploy your operator: Run the following commands to build and deploy your operator:

```shell
$ make docker-build docker-push IMG=example/my-operator:latest
$ make deploy IMG=example/my-operator:latest
```
This will build a Docker image for your operator, push it to a registry, and deploy it to your Kubernetes cluster.

Both Kubebuilder and Operator SDK are powerful tools for building Kubernetes operators, with Operator SDK providing more features and integrations on top of Kubebuilder's foundations.

- Use Kubebuilder if: You prefer a lightweight framework specifically for Go operators and want direct integration with Kubernetes SIG projects.
- Use Operator SDK if: You need additional features, support for Ansible or Helm operators, and tools for testing, monitoring, and lifecycle management.

Both frameworks follow similar workflows for scaffolding CRDs and controllers, so the choice often comes down to specific project requirements and preferences.

## ConfigmapSync Operator
***This operator is designed to seamlessly synchronize config maps from one namespace to others within a cluster. The usecase is there are so many environments
like dev/QAT. There are configmaps for each provider which will be created in the dev environment needs to be synchronized with QAT environment***

### Step1: Generate a new Kubebuilder project for your operator:

```bash
kubebuilder init --domain your.domain --repo github.com/your/repo
```

### Step 2: Create a ConfigMapCopy API and Controller
Generate a new API and Controller:

```bash
kubebuilder create api --group core --version v1 --kind ConfigMapCopy
```

### Step 3: Define the API for ConfigMapCopy
Edit api/v1/configmapcopy_types.go to define the API structure:

```go
package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ConfigMapCopySpec defines the desired state of ConfigMapCopy
type ConfigMapCopySpec struct {
	SourceNamespace string `json:"sourceNamespace"`
	TargetNamespace string `json:"targetNamespace"`
}

// ConfigMapCopyStatus defines the observed state of ConfigMapCopy
type ConfigMapCopyStatus struct {
	// ObservedGeneration is the most recent generation observed for this ConfigMapCopy.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// ConfigMapCopy is the Schema for the configmapcopies API
type ConfigMapCopy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ConfigMapCopySpec   `json:"spec,omitempty"`
	Status ConfigMapCopyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ConfigMapCopyList contains a list of ConfigMapCopy
type ConfigMapCopyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ConfigMapCopy `json:"items"`
}

func init() {
	SchemeBuilder.Register(&ConfigMapCopy{}, &ConfigMapCopyList{})
}
```

## What is ConfigMapCopySpec, ConfigMapCopyStatus signifies, how they are related to CRD, CR or to the actual configmap object? 
### ConfigMapCopySpec

Significance: ConfigMapCopySpec defines the desired state of the ConfigMapCopy resource. This includes any configuration details needed for the operator to perform its task. In this case, it includes the source namespace and target namespace for copying ConfigMaps.

Relation to CRD and CR: The ConfigMapCopySpec is part of the ConfigMapCopy CR defined by the CRD. When you create a ConfigMapCopy CR, you fill out the spec field with the desired configuration.

Example:

```go
type ConfigMapCopySpec struct {
    SourceNamespace string `json:"sourceNamespace"`
    TargetNamespace string `json:"targetNamespace"`
}
```

YAML Representation:

```yaml
apiVersion: core.your.domain/v1
kind: ConfigMapCopy
metadata:
  name: example-configmapcopy
spec:
  sourceNamespace: "source-namespace"
  targetNamespace: "target-namespace"
```

### ConfigMapCopyStatus

Significance: ConfigMapCopyStatus tracks the current status of the ConfigMapCopy resource. This includes fields that the operator updates to reflect the actual state of the resource. In this case, it includes the ObservedGeneration, which helps track the generation of the resource that the operator has processed.

Relation to CRD and CR: The ConfigMapCopyStatus is also part of the ConfigMapCopy CR defined by the CRD. The operator updates the status field in the CR to reflect the current state.

Example:

```go
type ConfigMapCopyStatus struct {
    ObservedGeneration int64 `json:"observedGeneration,omitempty"`
}
```

## Sequence of Flow

```txt
1. Deploy CRD
   |
   V
+----------------------------------+
| Define ConfigMapCopy CRD         |
+----------------------------------+
   |
   V
2. Deploy Operator
   |
   V
+----------------------------------+
| Operator deployed,               |
| starts watching ConfigMapCopy CRs|
+----------------------------------+
   |
   V
3. Create CR
   |
   V
+----------------------------------+
| Create ConfigMapCopy CR,         |
| specifying source and target NS  |
+----------------------------------+
   |
   V
4. Operator Monitors ConfigMaps
   |
   V
+----------------------------------+
| Operator watches ConfigMaps in   |
| source namespace specified in CR |
+----------------------------------+
   |
   V
5. Handle ConfigMap Events
   |      |      |
   |      |      |
   |      |      |
  Create Update Delete
   |      |      |
   V      V      V
+----------------------------------+
| Operator copies/updates/deletes  |
| ConfigMaps in target namespace   |
+----------------------------------+
   |
   V
6. Update ObservedGeneration
   |
   V
+----------------------------------+
| Operator updates CR status with  |
| ObservedGeneration               |
+----------------------------------+
```

## Summary
- CRD: Defines the schema and validation for a new custom resource type.
- CR: An instance of the custom resource, specifying the desired state.
- Operator: A controller that watches for changes in the custom resources and performs actions to manage the resources according to the desired state specified in 
  the CRs.




